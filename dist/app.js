/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/app.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/Firebase/FirebaseEvents.js":
/*!****************************************!*\
  !*** ./src/Firebase/FirebaseEvents.js ***!
  \****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _on_dispatchOnEvent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../on/dispatchOnEvent */ \"./src/on/dispatchOnEvent.js\");\n/* harmony import */ var _d20_d20__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../d20/d20 */ \"./src/d20/d20.js\");\n/* harmony import */ var _chat_const__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../chat/const */ \"./src/chat/const.js\");\n\r\n\r\n\r\n\r\nlet firebase;\r\n\r\nclass FirebaseEvents {\r\n\r\n    constructor(){\r\n        if(typeof firebase === 'undefined')\r\n            firebase = new Firebase(window.FIREBASE_ROOT + window.campaign_storage_path + \"/\");\r\n    }\r\n\r\n    initChatEvents(){\r\n        let firebaseChat = firebase.child(\"chat\");\r\n        let firebaseChatListener = firebaseChat.limitToLast(100);\r\n        firebaseChatListener.on('child_added', event => {\r\n            Object(_on_dispatchOnEvent__WEBPACK_IMPORTED_MODULE_0__[\"default\"])('chat:message', event.val());\r\n        });\r\n    }\r\n\r\n    async sendToChat(speakingAs, command, callback){\r\n        let message;\r\n        for(let line of command){\r\n            switch(line.type){\r\n                case _chat_const__WEBPACK_IMPORTED_MODULE_2__[\"ROLLRESULT_MESSAGE_TYPE\"]:\r\n                    message = {\r\n                        who: speakingAs,\r\n                        type: line.type,\r\n                        htmlcontent: line.htmlcontent,\r\n                        content: line.json,\r\n                        origRoll: line.origRoll,\r\n                        signature: line.signature,\r\n                        avatar: \"/users/avatar/161928/30\",\r\n                        playerid: window.currentPlayer.id,\r\n                        timestamp: (new Date).getTime(),\r\n                        _fbid: line._fbid,\r\n                    };\r\n                    break;\r\n                case _chat_const__WEBPACK_IMPORTED_MODULE_2__[\"GENERAL_MESSAGE_TYPE\"]:\r\n                    message = {\r\n                        who: speakingAs,\r\n                        type: line.type,\r\n                        content: line.text,\r\n                        avatar: \"/users/avatar/161928/30\",\r\n                    };\r\n                    break;\r\n            }\r\n            //Roll final tempalte func - 3112 i += r.call(e[s], o, s, e, r)\r\n            let firebaseChat = firebase.child(\"chat\");\r\n            let chatKey = firebaseChat.push().key();\r\n            firebaseChat.child(chatKey).setWithPriority(message, Firebase.ServerValue.TIMESTAMP)\r\n        }\r\n    }\r\n}\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (FirebaseEvents);\n\n//# sourceURL=webpack:///./src/Firebase/FirebaseEvents.js?");

/***/ }),

/***/ "./src/app.js":
/*!********************!*\
  !*** ./src/app.js ***!
  \********************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Firebase_FirebaseEvents__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Firebase/FirebaseEvents */ \"./src/Firebase/FirebaseEvents.js\");\n//require global functions\r\n__webpack_require__(/*! ./chat/sendChat.js */ \"./src/chat/sendChat.js\");\r\n\r\n\r\n\r\nfunction start(){\r\n    console.log(\"AVAILABLE!\");\r\n    let firebaseEvents = new _Firebase_FirebaseEvents__WEBPACK_IMPORTED_MODULE_0__[\"default\"]();\r\n    firebaseEvents.initChatEvents();\r\n}\r\nconsole.log(\"START!\");\r\nfunction whenAvailable(name, callback) {\r\n    var interval = 10; // ms\r\n    window.setTimeout(function() {\r\n        if (window[name]) {\r\n            callback(window[name]);\r\n        } else {\r\n            window.setTimeout(whenAvailable.bind(null, name, callback), interval);\r\n        }\r\n    }, interval);\r\n}\r\n\r\nwhenAvailable('currentPlayer', start);\r\n\r\n//players\r\n//characters\r\n///char-attribs/char/-LqNL6ygV93sW5RdFI7C/-M5HluzGebUmm730-7id\r\n\r\n// Backbone.sync = function(e, n, s) {\r\n//     if (n.nofirebase)\r\n//         return o(e, n, s);\r\n//     if (r(),\r\n//     typeof Firebase === t)\r\n//         return !1;\r\n//     s || (s = {});\r\n//     try {\r\n//         var l = a(n, \"url\")\r\n//     } catch (d) {\r\n//         return void console.log(\"No url, probably already deleted.\")\r\n//     }\r\n//     var c = new Firebase(i + l)\r\n//       , u = !0;\r\n//     switch (n.collection === t && (u = !1),\r\n//     e) {\r\n//     case \"read\":\r\n//         c.once(\"value\", function(e) {\r\n//             e = _.toArray(e.val()),\r\n//             s.success && s.success(e, \"success\", {})\r\n//         });\r\n//         break;\r\n//     case \"create\":\r\n//     case \"update\":\r\n//         (new Date).getTime();\r\n//         c.once(\"value\", function(e) {\r\n//             var i = e.val();\r\n//             null == i && (i = {},\r\n//             n.persisted = !0);\r\n//             var o = n.toJSON()\r\n//               , r = {};\r\n//             for (var a in o)\r\n//                 if (i[a] === t)\r\n//                     o[a] !== n.defaults[a] && (r[a] = o[a]);\r\n//                 else if (window.is_gm && u && o[a] === n.defaults[a])\r\n//                     r[a] = null;\r\n//                 else if (i[a] !== o[a]) {\r\n//                     if (\"object\" == typeof o[a] && _.isEqual(i[a], o[a]))\r\n//                         continue;\r\n//                     r[a] = o[a]\r\n//                 }\r\n//             _.keys(r).length > 0 && (n._ignore_remote = !0,\r\n//             c.update(r, function(e) {\r\n//                 !e && s.success ? s.success() : e && s.error && s.error()\r\n//             }),\r\n//             n._ignore_remote = !1)\r\n//         }, function() {\r\n//             \"tutorial\" !== window.GNTKN ? (console.log(\"ERROR: UNABLE TO READ OR SET DATA\"),\r\n//             alert(\"Unable to read or set data from server. There may be a problem with your session. Try reloading the page to fix this issue. If you are persistently receiving this error, please contact your ISP for support.\")) : s.success && s.success()\r\n//         });\r\n//         break;\r\n//     case \"delete\":\r\n//         c.remove(function(e) {\r\n//             !e && s.success ? s.success() : e && s.error && s.error()\r\n//         })\r\n//     }\r\n//     return c\r\n// }\r\n// ;\r\n// var a = function(e, t) {\r\n//     return e && e[t] ? _.isFunction(e[t]) ? e[t]() : e[t] : null\r\n// };\r\n// e.BackboneFirebase = n\r\n// }(\"undefined\" != typeof exports ? exports : this),\n\n//# sourceURL=webpack:///./src/app.js?");

/***/ }),

/***/ "./src/chat/const.js":
/*!***************************!*\
  !*** ./src/chat/const.js ***!
  \***************************/
/*! exports provided: GENERAL_MESSAGE_TYPE, ROLLRESULT_MESSAGE_TYPE */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"GENERAL_MESSAGE_TYPE\", function() { return GENERAL_MESSAGE_TYPE; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ROLLRESULT_MESSAGE_TYPE\", function() { return ROLLRESULT_MESSAGE_TYPE; });\nconst GENERAL_MESSAGE_TYPE = 'general';\r\nconst ROLLRESULT_MESSAGE_TYPE = 'rollresult';\n\n//# sourceURL=webpack:///./src/chat/const.js?");

/***/ }),

/***/ "./src/chat/sendChat.js":
/*!******************************!*\
  !*** ./src/chat/sendChat.js ***!
  \******************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Firebase_FirebaseEvents__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Firebase/FirebaseEvents */ \"./src/Firebase/FirebaseEvents.js\");\n/* harmony import */ var _d20_d20__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../d20/d20 */ \"./src/d20/d20.js\");\n/* harmony import */ var _const__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./const */ \"./src/chat/const.js\");\n\r\n\r\n\r\n\r\nclass SendChatHelper {\r\n\r\n    getHtmlContentByRollResultJson(rollResult){\r\n        return d20ext.dice_formatter.getHtmlForResult(JSON.parse(rollResult))\r\n    }\r\n    \r\n    async getCommand(input){\r\n        let rollRegexp = new RegExp(/\\/((roll)|(r)|(gmroll)|(gr))[ ]+/i);\r\n        let command = $.trim(input);\r\n        if(rollRegexp.test(command)){\r\n            let origRoll = command.replace(rollRegexp, '');\r\n            command = await _d20_d20__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getRollResults(origRoll);\r\n            command = command.map((item) => {\r\n                item.origRoll = origRoll;\r\n                item.type = _const__WEBPACK_IMPORTED_MODULE_2__[\"ROLLRESULT_MESSAGE_TYPE\"];\r\n                item.htmlcontent = this.getHtmlContentByRollResultJson(item.json);\r\n                item._fbid = item.key;\r\n                return item;\r\n            });\r\n        }\r\n        else{\r\n            command = {\r\n                text: input,\r\n                type: _const__WEBPACK_IMPORTED_MODULE_2__[\"GENERAL_MESSAGE_TYPE\"],\r\n            }\r\n            command = [command];\r\n        }\r\n        return command;\r\n    }\r\n}\r\n\r\nasync function sendChat(speakingAs, input, callback, options) {\r\n    let sendChatHelper = new SendChatHelper();\r\n    let command = await sendChatHelper.getCommand(input);\r\n    let firebaseEvents = new _Firebase_FirebaseEvents__WEBPACK_IMPORTED_MODULE_0__[\"default\"]();\r\n    return firebaseEvents.sendToChat(speakingAs, command, callback, options);\r\n};\r\n\r\n\r\n\r\nwindow.sendChat = sendChat;\n\n//# sourceURL=webpack:///./src/chat/sendChat.js?");

/***/ }),

/***/ "./src/d20/d20.js":
/*!************************!*\
  !*** ./src/d20/d20.js ***!
  \************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\nlet d20 = {};\r\n\r\nd20.DicePEG = function() {\r\n    function quote(e) {\r\n        return '\"' + e.replace(/\\\\/g, \"\\\\\\\\\").replace(/\"/g, '\\\\\"').replace(/\\x08/g, \"\\\\b\").replace(/\\t/g, \"\\\\t\").replace(/\\n/g, \"\\\\n\").replace(/\\f/g, \"\\\\f\").replace(/\\r/g, \"\\\\r\").replace(/[\\x00-\\x07\\x0B\\x0E-\\x1F\\x80-\\uFFFF]/g, escape) + '\"'\r\n    }\r\n    var result = {\r\n        parse: function(input, startRule) {\r\n            function padLeft(e, t, i) {\r\n                for (var n = e, o = i - e.length, r = 0; r < o; r++)\r\n                    n = t + n;\r\n                return n\r\n            }\r\n            function escape(e) {\r\n                var t, i, n = e.charCodeAt(0);\r\n                return n <= 255 ? (t = \"x\",\r\n                i = 2) : (t = \"u\",\r\n                i = 4),\r\n                \"\\\\\" + t + padLeft(n.toString(16).toUpperCase(), \"0\", i)\r\n            }\r\n            function matchFailed(e) {\r\n                pos < rightmostFailuresPos || (pos > rightmostFailuresPos && (rightmostFailuresPos = pos,\r\n                rightmostFailuresExpected = []),\r\n                rightmostFailuresExpected.push(e))\r\n            }\r\n            function parse_start() {\r\n                var e, t, i, n, o, r, a;\r\n                if (n = pos,\r\n                o = pos,\r\n                null !== (e = parse_rollExpression())) {\r\n                    for (t = [],\r\n                    input.length > pos ? (i = input.charAt(pos),\r\n                    pos++) : (i = null,\r\n                    0 === reportFailures && matchFailed(\"any character\")); null !== i; )\r\n                        t.push(i),\r\n                        input.length > pos ? (i = input.charAt(pos),\r\n                        pos++) : (i = null,\r\n                        0 === reportFailures && matchFailed(\"any character\"));\r\n                    null !== t ? e = [e, t] : (e = null,\r\n                    pos = o)\r\n                } else\r\n                    e = null,\r\n                    pos = o;\r\n                return null !== e && (r = e[0],\r\n                a = e[1],\r\n                Array.isArray(r) || (r = [r]),\r\n                \"\" !== a && (a = a.join(\"\")).trim().length > 0 && r.push(new Comment(a)),\r\n                e = r),\r\n                null === e && (pos = n),\r\n                e\r\n            }\r\n            function parse_rollExpression() {\r\n                var e, t, i, n, o, r, a, s, l;\r\n                return n = pos,\r\n                o = pos,\r\n                null !== (e = parse_rollExpressionPrimary()) && null !== (t = parse_labelAwareRollOperator()) && null !== (i = parse_rollExpression()) ? e = [e, t, i] : (e = null,\r\n                pos = o),\r\n                null !== e && (r = e[0],\r\n                a = e[1],\r\n                s = e[2],\r\n                e = mergeExpressions(mergeExpressions(r, a), s)),\r\n                null === e && (pos = n),\r\n                null === e && (n = pos,\r\n                o = pos,\r\n                null !== (e = parse_rollExpressionPrimary()) && null !== (t = parse_inlineLabelWithSpace()) ? e = [e, t] : (e = null,\r\n                pos = o),\r\n                null !== e && (e = mergeExpressions(e[0], e[1])),\r\n                null === e && (pos = n),\r\n                null === e && (n = pos,\r\n                o = pos,\r\n                null !== (e = parse_inlineLabelWithSpace()) && null !== (t = parse_rollExpression()) ? e = [e, t] : (e = null,\r\n                pos = o),\r\n                null !== e && (e = mergeExpressions(e[0], e[1])),\r\n                null === e && (pos = n),\r\n                null === e && (n = pos,\r\n                null !== (e = parse_rollExpressionPrimary()) && (l = e,\r\n                Array.isArray(l) || (l = [l]),\r\n                e = l),\r\n                null === e && (pos = n)))),\r\n                e\r\n            }\r\n            function parse_rollExpressionPrimary() {\r\n                var e, t, i, n, o, r, a, s;\r\n                return r = pos,\r\n                a = pos,\r\n                null !== (e = parse_fullRoll()) ? (s = pos,\r\n                reportFailures++,\r\n                t = parse_validRollSuffix(),\r\n                reportFailures--,\r\n                null !== t ? (t = \"\",\r\n                pos = s) : t = null,\r\n                null !== t ? e = [e, t] : (e = null,\r\n                pos = a)) : (e = null,\r\n                pos = a),\r\n                null !== e && (e = e[0]),\r\n                null === e && (pos = r),\r\n                null === e && (r = pos,\r\n                a = pos,\r\n                null !== (e = parse_rollGroup()) ? (s = pos,\r\n                reportFailures++,\r\n                t = parse_validRollSuffix(),\r\n                reportFailures--,\r\n                null !== t ? (t = \"\",\r\n                pos = s) : t = null,\r\n                null !== t ? e = [e, t] : (e = null,\r\n                pos = a)) : (e = null,\r\n                pos = a),\r\n                null !== e && (e = e[0]),\r\n                null === e && (pos = r),\r\n                null === e && (r = pos,\r\n                null !== (e = parse_number()) && (e = new MathExpression(e)),\r\n                null === e && (pos = r),\r\n                null === e && (r = pos,\r\n                a = pos,\r\n                \"floor(\" === input.substr(pos, 6) ? (e = \"floor(\",\r\n                pos += 6) : (e = null,\r\n                0 === reportFailures && matchFailed('\"floor(\"')),\r\n                null !== e && null !== (t = parse__()) && null !== (i = parse_rollExpression()) && null !== (n = parse__()) ? (41 === input.charCodeAt(pos) ? (o = \")\",\r\n                pos++) : (o = null,\r\n                0 === reportFailures && matchFailed('\")\"')),\r\n                null !== o ? e = [e, t, i, n, o] : (e = null,\r\n                pos = a)) : (e = null,\r\n                pos = a),\r\n                null !== e && (e = mergeExpressions(\"floor(\", mergeExpressions(e[2], \")\"))),\r\n                null === e && (pos = r),\r\n                null === e && (r = pos,\r\n                a = pos,\r\n                \"ceil(\" === input.substr(pos, 5) ? (e = \"ceil(\",\r\n                pos += 5) : (e = null,\r\n                0 === reportFailures && matchFailed('\"ceil(\"')),\r\n                null !== e && null !== (t = parse__()) && null !== (i = parse_rollExpression()) && null !== (n = parse__()) ? (41 === input.charCodeAt(pos) ? (o = \")\",\r\n                pos++) : (o = null,\r\n                0 === reportFailures && matchFailed('\")\"')),\r\n                null !== o ? e = [e, t, i, n, o] : (e = null,\r\n                pos = a)) : (e = null,\r\n                pos = a),\r\n                null !== e && (e = mergeExpressions(\"ceil(\", mergeExpressions(e[2], \")\"))),\r\n                null === e && (pos = r),\r\n                null === e && (r = pos,\r\n                a = pos,\r\n                \"round(\" === input.substr(pos, 6) ? (e = \"round(\",\r\n                pos += 6) : (e = null,\r\n                0 === reportFailures && matchFailed('\"round(\"')),\r\n                null !== e && null !== (t = parse__()) && null !== (i = parse_rollExpression()) && null !== (n = parse__()) ? (41 === input.charCodeAt(pos) ? (o = \")\",\r\n                pos++) : (o = null,\r\n                0 === reportFailures && matchFailed('\")\"')),\r\n                null !== o ? e = [e, t, i, n, o] : (e = null,\r\n                pos = a)) : (e = null,\r\n                pos = a),\r\n                null !== e && (e = mergeExpressions(\"round(\", mergeExpressions(e[2], \")\"))),\r\n                null === e && (pos = r),\r\n                null === e && (r = pos,\r\n                a = pos,\r\n                \"abs(\" === input.substr(pos, 4) ? (e = \"abs(\",\r\n                pos += 4) : (e = null,\r\n                0 === reportFailures && matchFailed('\"abs(\"')),\r\n                null !== e && null !== (t = parse__()) && null !== (i = parse_rollExpression()) && null !== (n = parse__()) ? (41 === input.charCodeAt(pos) ? (o = \")\",\r\n                pos++) : (o = null,\r\n                0 === reportFailures && matchFailed('\")\"')),\r\n                null !== o ? e = [e, t, i, n, o] : (e = null,\r\n                pos = a)) : (e = null,\r\n                pos = a),\r\n                null !== e && (e = mergeExpressions(\"abs(\", mergeExpressions(e[2], \")\"))),\r\n                null === e && (pos = r),\r\n                null === e && (r = pos,\r\n                a = pos,\r\n                40 === input.charCodeAt(pos) ? (e = \"(\",\r\n                pos++) : (e = null,\r\n                0 === reportFailures && matchFailed('\"(\"')),\r\n                null !== e && null !== (t = parse__()) && null !== (i = parse_rollExpression()) && null !== (n = parse__()) ? (41 === input.charCodeAt(pos) ? (o = \")\",\r\n                pos++) : (o = null,\r\n                0 === reportFailures && matchFailed('\")\"')),\r\n                null !== o ? e = [e, t, i, n, o] : (e = null,\r\n                pos = a)) : (e = null,\r\n                pos = a),\r\n                null !== e && (e = mergeExpressions(\"(\", mergeExpressions(e[2], \")\"))),\r\n                null === e && (pos = r)))))))),\r\n                e\r\n            }\r\n            function parse_validRollSuffix() {\r\n                var e, t;\r\n                return null === (e = parse___()) && null === (e = parse_inlineLabelWithSpace()) && (125 === input.charCodeAt(pos) ? (e = \"}\",\r\n                pos++) : (e = null,\r\n                0 === reportFailures && matchFailed('\"}\"')),\r\n                null === e && (44 === input.charCodeAt(pos) ? (e = \",\",\r\n                pos++) : (e = null,\r\n                0 === reportFailures && matchFailed('\",\"')),\r\n                null === e && (41 === input.charCodeAt(pos) ? (e = \")\",\r\n                pos++) : (e = null,\r\n                0 === reportFailures && matchFailed('\")\"')),\r\n                null === e && (t = pos,\r\n                reportFailures++,\r\n                e = parse_operator(),\r\n                reportFailures--,\r\n                null !== e ? (e = \"\",\r\n                pos = t) : e = null,\r\n                null === e && (t = pos,\r\n                reportFailures++,\r\n                input.length > pos ? (e = input.charAt(pos),\r\n                pos++) : (e = null,\r\n                0 === reportFailures && matchFailed(\"any character\")),\r\n                reportFailures--,\r\n                null === e ? e = \"\" : (e = null,\r\n                pos = t)))))),\r\n                e\r\n            }\r\n            function parse_rollGroup() {\r\n                var e, t, i, n, o, r, a, s;\r\n                return a = pos,\r\n                s = pos,\r\n                123 === input.charCodeAt(pos) ? (e = \"{\",\r\n                pos++) : (e = null,\r\n                0 === reportFailures && matchFailed('\"{\"')),\r\n                null !== e && null !== (t = parse__()) && null !== (i = parse_rollGroupExpression()) && null !== (n = parse__()) ? (125 === input.charCodeAt(pos) ? (o = \"}\",\r\n                pos++) : (o = null,\r\n                0 === reportFailures && matchFailed('\"}\"')),\r\n                null !== o && null !== (r = null !== (r = parse_groupMods()) ? r : \"\") ? e = [e, t, i, n, o, r] : (e = null,\r\n                pos = s)) : (e = null,\r\n                pos = s),\r\n                null !== e && (e = new GroupExpression(e[2],e[5])),\r\n                null === e && (pos = a),\r\n                e\r\n            }\r\n            function parse_rollGroupExpression() {\r\n                var e, t, i, n, o, r, a, s, l;\r\n                return r = pos,\r\n                a = pos,\r\n                null === (e = parse_rollExpression()) && (e = parse_rollGroup()),\r\n                null !== e && null !== (t = parse__()) ? (44 === input.charCodeAt(pos) ? (i = \",\",\r\n                pos++) : (i = null,\r\n                0 === reportFailures && matchFailed('\",\"')),\r\n                null !== i && null !== (n = parse__()) && null !== (o = parse_rollGroupExpression()) ? e = [e, t, i, n, o] : (e = null,\r\n                pos = a)) : (e = null,\r\n                pos = a),\r\n                null !== e && (s = e[0],\r\n                l = e[4],\r\n                Array.isArray(s) || (s = [s]),\r\n                e = \"\" !== l ? [s].concat(l) : s),\r\n                null === e && (pos = r),\r\n                null === e && (r = pos,\r\n                null === (e = parse_rollExpression()) && (e = parse_rollGroup()),\r\n                null !== e && (e = [e]),\r\n                null === e && (pos = r)),\r\n                e\r\n            }\r\n            function parse_labelAwareRollOperator() {\r\n                var e, t, i, n, o;\r\n                if (n = pos,\r\n                o = pos,\r\n                null !== (e = parse_rollOperator())) {\r\n                    for (t = [],\r\n                    null === (i = parse_rollOperator()) && (i = parse_inlineLabelWithSpace()); null !== i; )\r\n                        t.push(i),\r\n                        null === (i = parse_rollOperator()) && (i = parse_inlineLabelWithSpace());\r\n                    null !== t ? e = [e, t] : (e = null,\r\n                    pos = o)\r\n                } else\r\n                    e = null,\r\n                    pos = o;\r\n                return null !== e && (e = function(e, t, i) {\r\n                    for (var n = t, o = 0; o < i.length; o++)\r\n                        n = mergeExpressions(n, i[o]);\r\n                    return n\r\n                }(0, e[0], e[1])),\r\n                null === e && (pos = n),\r\n                null === e && (n = pos,\r\n                o = pos,\r\n                null !== (e = parse_inlineLabelWithSpace()) && null !== (t = parse_labelAwareRollOperator()) ? e = [e, t] : (e = null,\r\n                pos = o),\r\n                null !== e && (e = mergeExpressions(e[0], e[1])),\r\n                null === e && (pos = n)),\r\n                e\r\n            }\r\n            function parse_rollOperator() {\r\n                var e, t, i, n, o, r, a, s, l;\r\n                return s = pos,\r\n                l = pos,\r\n                null !== (e = parse__()) && null !== (t = parse_operator()) && null !== (i = parse__()) && null !== (n = parse_mathExpressionPrimary()) && null !== (o = parse__()) && null !== (r = parse_rollOperator()) && null !== (a = parse__()) ? e = [e, t, i, n, o, r, a] : (e = null,\r\n                pos = l),\r\n                null !== e && (e = e[1] + e[3] + e[5]),\r\n                null === e && (pos = s),\r\n                null === e && (s = pos,\r\n                l = pos,\r\n                null !== (e = parse__()) && null !== (t = parse_operator()) && null !== (i = parse__()) ? e = [e, t, i] : (e = null,\r\n                pos = l),\r\n                null !== e && (e = e[1]),\r\n                null === e && (pos = s)),\r\n                e\r\n            }\r\n            function parse_fullRoll() {\r\n                var e, t, i, n, o, r, a;\r\n                return n = pos,\r\n                o = pos,\r\n                null !== (e = parse_coreRoll()) && null !== (t = null !== (t = parse_rollMods()) ? t : \"\") ? e = [e, t] : (e = null,\r\n                pos = o),\r\n                null !== e && (r = e[0],\r\n                \"\" !== (a = e[1]) && (r.mods = a),\r\n                e = r),\r\n                null === e && (pos = n),\r\n                null === e && (n = pos,\r\n                o = pos,\r\n                null !== (e = parse_numberOfDice()) ? (\"t\" === input.substr(pos, 1).toLowerCase() ? (t = input.substr(pos, 1),\r\n                pos++) : (t = null,\r\n                0 === reportFailures && matchFailed('\"t\"')),\r\n                null !== t && null !== (i = parse_inlineLabel()) ? e = [e, t, i] : (e = null,\r\n                pos = o)) : (e = null,\r\n                pos = o),\r\n                null !== e && (e = new TableRollExpression(e[0],e[2].text)),\r\n                null === e && (pos = n)),\r\n                e\r\n            }\r\n            function parse_coreRoll() {\r\n                var e, t, i, n, o;\r\n                return n = pos,\r\n                o = pos,\r\n                null !== (e = parse_numberOfDice()) ? (\"d\" === input.substr(pos, 1).toLowerCase() ? (t = input.substr(pos, 1),\r\n                pos++) : (t = null,\r\n                0 === reportFailures && matchFailed('\"d\"')),\r\n                null !== t ? (\"f\" === input.substr(pos, 1).toLowerCase() ? (i = input.substr(pos, 1),\r\n                pos++) : (i = null,\r\n                0 === reportFailures && matchFailed('\"f\"')),\r\n                null !== i ? e = [e, t, i] : (e = null,\r\n                pos = o)) : (e = null,\r\n                pos = o)) : (e = null,\r\n                pos = o),\r\n                null !== e && (e = new FateRollExpression(e[0])),\r\n                null === e && (pos = n),\r\n                null === e && (n = pos,\r\n                o = pos,\r\n                null !== (e = parse_numberOfDice()) ? (\"d\" === input.substr(pos, 1).toLowerCase() ? (t = input.substr(pos, 1),\r\n                pos++) : (t = null,\r\n                0 === reportFailures && matchFailed('\"d\"')),\r\n                null !== t && null !== (i = parse_numberOfSides()) ? e = [e, t, i] : (e = null,\r\n                pos = o)) : (e = null,\r\n                pos = o),\r\n                null !== e && (e = new RollExpression(e[0],e[2])),\r\n                null === e && (pos = n)),\r\n                e\r\n            }\r\n            function parse_numberOfDice() {\r\n                var result0, result1, result2, result3, result4, pos0, pos1;\r\n                return result0 = parse_integer(),\r\n                null === result0 && (pos0 = pos,\r\n                pos1 = pos,\r\n                40 === input.charCodeAt(pos) ? (result0 = \"(\",\r\n                pos++) : (result0 = null,\r\n                0 === reportFailures && matchFailed('\"(\"')),\r\n                null !== result0 ? (result1 = parse__(),\r\n                null !== result1 ? (result2 = parse_mathExpression(),\r\n                null !== result2 ? (result3 = parse__(),\r\n                null !== result3 ? (41 === input.charCodeAt(pos) ? (result4 = \")\",\r\n                pos++) : (result4 = null,\r\n                0 === reportFailures && matchFailed('\")\"')),\r\n                null !== result4 ? result0 = [result0, result1, result2, result3, result4] : (result0 = null,\r\n                pos = pos1)) : (result0 = null,\r\n                pos = pos1)) : (result0 = null,\r\n                pos = pos1)) : (result0 = null,\r\n                pos = pos1)) : (result0 = null,\r\n                pos = pos1),\r\n                null !== result0 && (result0 = function(offset, expr) {\r\n                    return Math.round(eval(\"(\" + expr + \")\"))\r\n                }(pos0, result0[2])),\r\n                null === result0 && (pos = pos0),\r\n                null === result0 && (pos0 = pos,\r\n                result0 = \"\",\r\n                null !== result0 && (result0 = 1),\r\n                null === result0 && (pos = pos0))),\r\n                result0\r\n            }\r\n            function parse_numberOfSides() {\r\n                var result0, result1, result2, result3, result4, pos0, pos1;\r\n                return result0 = parse_integer(),\r\n                null === result0 && (pos0 = pos,\r\n                pos1 = pos,\r\n                40 === input.charCodeAt(pos) ? (result0 = \"(\",\r\n                pos++) : (result0 = null,\r\n                0 === reportFailures && matchFailed('\"(\"')),\r\n                null !== result0 ? (result1 = parse__(),\r\n                null !== result1 ? (result2 = parse_mathExpression(),\r\n                null !== result2 ? (result3 = parse__(),\r\n                null !== result3 ? (41 === input.charCodeAt(pos) ? (result4 = \")\",\r\n                pos++) : (result4 = null,\r\n                0 === reportFailures && matchFailed('\")\"')),\r\n                null !== result4 ? result0 = [result0, result1, result2, result3, result4] : (result0 = null,\r\n                pos = pos1)) : (result0 = null,\r\n                pos = pos1)) : (result0 = null,\r\n                pos = pos1)) : (result0 = null,\r\n                pos = pos1)) : (result0 = null,\r\n                pos = pos1),\r\n                null !== result0 && (result0 = function(offset, expr) {\r\n                    return Math.round(eval(\"(\" + expr + \")\"))\r\n                }(pos0, result0[2])),\r\n                null === result0 && (pos = pos0),\r\n                null === result0 && (pos0 = pos,\r\n                \"f\" === input.substr(pos, 1).toLowerCase() ? (result0 = input.substr(pos, 1),\r\n                pos++) : (result0 = null,\r\n                0 === reportFailures && matchFailed('\"f\"')),\r\n                null !== result0 && (result0 = \"F\"),\r\n                null === result0 && (pos = pos0))),\r\n                result0\r\n            }\r\n            function parse_groupMods() {\r\n                var e, t, i, n, o;\r\n                if (n = pos,\r\n                o = pos,\r\n                null === (e = parse_keepMod()) && null === (e = parse_dropMod()) && null === (e = parse_multipleMod()) && null === (e = parse_matchTotalMod()) && null === (e = parse_matchMod()) && (e = parse_successMod()),\r\n                null !== e) {\r\n                    for (t = [],\r\n                    i = parse_groupMods(); null !== i; )\r\n                        t.push(i),\r\n                        i = parse_groupMods();\r\n                    null !== t ? e = [e, t] : (e = null,\r\n                    pos = o)\r\n                } else\r\n                    e = null,\r\n                    pos = o;\r\n                return null !== e && (e = processMods(e[0], e[1])),\r\n                null === e && (pos = n),\r\n                e\r\n            }\r\n            function parse_rollMods() {\r\n                var e, t, i, n, o;\r\n                if (n = pos,\r\n                o = pos,\r\n                null === (e = parse_compoundingMod()) && null === (e = parse_penetratingMod()) && null === (e = parse_explodingMod()) && null === (e = parse_keepMod()) && null === (e = parse_dropMod()) && null === (e = parse_rerollOnceMod()) && null === (e = parse_rerollMod()) && null === (e = parse_customCritMod()) && null === (e = parse_customFumbleMod()) && null === (e = parse_sortMod()) && null === (e = parse_matchTotalMod()) && null === (e = parse_matchMod()) && (e = parse_successMod()),\r\n                null !== e) {\r\n                    for (t = [],\r\n                    i = parse_rollMods(); null !== i; )\r\n                        t.push(i),\r\n                        i = parse_rollMods();\r\n                    null !== t ? e = [e, t] : (e = null,\r\n                    pos = o)\r\n                } else\r\n                    e = null,\r\n                    pos = o;\r\n                return null !== e && (e = processMods(e[0], e[1])),\r\n                null === e && (pos = n),\r\n                e\r\n            }\r\n            function parse_explodingMod() {\r\n                var e, t, i, n;\r\n                return i = pos,\r\n                n = pos,\r\n                33 === input.charCodeAt(pos) ? (e = \"!\",\r\n                pos++) : (e = null,\r\n                0 === reportFailures && matchFailed('\"!\"')),\r\n                null !== e && null !== (t = null !== (t = parse_comparisonPoint()) ? t : \"\") ? e = [e, t] : (e = null,\r\n                pos = n),\r\n                null !== e && (e = {\r\n                    exploding: e[1]\r\n                }),\r\n                null === e && (pos = i),\r\n                e\r\n            }\r\n            function parse_compoundingMod() {\r\n                var e, t, i, n;\r\n                return i = pos,\r\n                n = pos,\r\n                \"!!\" === input.substr(pos, 2) ? (e = \"!!\",\r\n                pos += 2) : (e = null,\r\n                0 === reportFailures && matchFailed('\"!!\"')),\r\n                null !== e && null !== (t = null !== (t = parse_comparisonPoint()) ? t : \"\") ? e = [e, t] : (e = null,\r\n                pos = n),\r\n                null !== e && (e = {\r\n                    compounding: e[1]\r\n                }),\r\n                null === e && (pos = i),\r\n                e\r\n            }\r\n            function parse_penetratingMod() {\r\n                var e, t, i, n, o;\r\n                return n = pos,\r\n                o = pos,\r\n                33 === input.charCodeAt(pos) ? (e = \"!\",\r\n                pos++) : (e = null,\r\n                0 === reportFailures && matchFailed('\"!\"')),\r\n                null !== e ? (\"p\" === input.substr(pos, 1).toLowerCase() ? (t = input.substr(pos, 1),\r\n                pos++) : (t = null,\r\n                0 === reportFailures && matchFailed('\"p\"')),\r\n                null !== t && null !== (i = null !== (i = parse_comparisonPoint()) ? i : \"\") ? e = [e, t, i] : (e = null,\r\n                pos = o)) : (e = null,\r\n                pos = o),\r\n                null !== e && (e = {\r\n                    penetrating: e[2]\r\n                }),\r\n                null === e && (pos = n),\r\n                e\r\n            }\r\n            function parse_keepMod() {\r\n                var e, t, i, n, o, r, a;\r\n                return n = pos,\r\n                o = pos,\r\n                \"k\" === input.substr(pos, 1).toLowerCase() ? (e = input.substr(pos, 1),\r\n                pos++) : (e = null,\r\n                0 === reportFailures && matchFailed('\"k\"')),\r\n                null !== e ? (/^['h'|'l']/i.test(input.charAt(pos)) ? (t = input.charAt(pos),\r\n                pos++) : (t = null,\r\n                0 === reportFailures && matchFailed(\"['h'|'l']i\")),\r\n                null !== (t = null !== t ? t : \"\") && null !== (i = parse_integer()) ? e = [e, t, i] : (e = null,\r\n                pos = o)) : (e = null,\r\n                pos = o),\r\n                null !== e && (r = e[1],\r\n                a = e[2],\r\n                e = {\r\n                    keep: {\r\n                        end: r.toLowerCase() || \"h\",\r\n                        count: a\r\n                    }\r\n                }),\r\n                null === e && (pos = n),\r\n                e\r\n            }\r\n            function parse_dropMod() {\r\n                var e, t, i, n, o, r, a;\r\n                return n = pos,\r\n                o = pos,\r\n                \"d\" === input.substr(pos, 1).toLowerCase() ? (e = input.substr(pos, 1),\r\n                pos++) : (e = null,\r\n                0 === reportFailures && matchFailed('\"d\"')),\r\n                null !== e ? (/^['h'|'l']/i.test(input.charAt(pos)) ? (t = input.charAt(pos),\r\n                pos++) : (t = null,\r\n                0 === reportFailures && matchFailed(\"['h'|'l']i\")),\r\n                null !== (t = null !== t ? t : \"\") && null !== (i = parse_integer()) ? e = [e, t, i] : (e = null,\r\n                pos = o)) : (e = null,\r\n                pos = o),\r\n                null !== e && (r = e[1],\r\n                a = e[2],\r\n                e = {\r\n                    drop: {\r\n                        end: r.toLowerCase() || \"l\",\r\n                        count: a\r\n                    }\r\n                }),\r\n                null === e && (pos = n),\r\n                e\r\n            }\r\n            function parse_customCritMod() {\r\n                var e, t, i, n, o, r, a, s;\r\n                return n = pos,\r\n                o = pos,\r\n                \"cs\" === input.substr(pos, 2).toLowerCase() ? (e = input.substr(pos, 2),\r\n                pos += 2) : (e = null,\r\n                0 === reportFailures && matchFailed('\"cs\"')),\r\n                null !== e && null !== (t = null !== (t = parse_comparisonPoint()) ? t : \"\") && null !== (i = null !== (i = parse_customCritMod()) ? i : \"\") ? e = [e, t, i] : (e = null,\r\n                pos = o),\r\n                null !== e && (r = e[1],\r\n                a = e[2],\r\n                s = {\r\n                    customCrit: \"\" !== r ? [r] : [{}]\r\n                },\r\n                \"\" !== a && (s.customCrit = s.customCrit.concat(a.customCrit)),\r\n                e = s),\r\n                null === e && (pos = n),\r\n                e\r\n            }\r\n            function parse_customFumbleMod() {\r\n                var e, t, i, n, o, r, a, s;\r\n                return n = pos,\r\n                o = pos,\r\n                \"cf\" === input.substr(pos, 2).toLowerCase() ? (e = input.substr(pos, 2),\r\n                pos += 2) : (e = null,\r\n                0 === reportFailures && matchFailed('\"cf\"')),\r\n                null !== e && null !== (t = null !== (t = parse_comparisonPoint()) ? t : \"\") && null !== (i = null !== (i = parse_customFumbleMod()) ? i : \"\") ? e = [e, t, i] : (e = null,\r\n                pos = o),\r\n                null !== e && (r = e[1],\r\n                a = e[2],\r\n                s = {\r\n                    customFumble: \"\" !== r ? [r] : [{}]\r\n                },\r\n                \"\" !== a && (s.customFumble = s.customFumble.concat(a.customFumble)),\r\n                e = s),\r\n                null === e && (pos = n),\r\n                e\r\n            }\r\n            function parse_rerollMod() {\r\n                var e, t, i, n, o, r, a, s;\r\n                return n = pos,\r\n                o = pos,\r\n                \"r\" === input.substr(pos, 1).toLowerCase() ? (e = input.substr(pos, 1),\r\n                pos++) : (e = null,\r\n                0 === reportFailures && matchFailed('\"r\"')),\r\n                null !== e && null !== (t = null !== (t = parse_comparisonPoint()) ? t : \"\") && null !== (i = null !== (i = parse_rerollMod()) ? i : \"\") ? e = [e, t, i] : (e = null,\r\n                pos = o),\r\n                null !== e && (r = e[1],\r\n                a = e[2],\r\n                s = {\r\n                    reroll: \"\" !== r ? [r] : [{}]\r\n                },\r\n                \"\" !== a && (s.reroll = s.reroll.concat(a.reroll)),\r\n                e = s),\r\n                null === e && (pos = n),\r\n                e\r\n            }\r\n            function parse_rerollOnceMod() {\r\n                var e, t, i, n, o, r, a, s;\r\n                return n = pos,\r\n                o = pos,\r\n                \"ro\" === input.substr(pos, 2).toLowerCase() ? (e = input.substr(pos, 2),\r\n                pos += 2) : (e = null,\r\n                0 === reportFailures && matchFailed('\"ro\"')),\r\n                null !== e && null !== (t = null !== (t = parse_comparisonPoint()) ? t : \"\") && null !== (i = null !== (i = parse_rerollMod()) ? i : \"\") ? e = [e, t, i] : (e = null,\r\n                pos = o),\r\n                null !== e && (r = e[1],\r\n                a = e[2],\r\n                s = {\r\n                    reroll: \"\" !== r ? [r] : [{}]\r\n                },\r\n                \"\" !== a && (s.reroll = s.reroll.concat(a.reroll)),\r\n                s.reroll && s.reroll[0] && (s.reroll[0].maxrerolls = 1),\r\n                e = s),\r\n                null === e && (pos = n),\r\n                e\r\n            }\r\n            function parse_sortMod() {\r\n                var e, t, i, n;\r\n                return i = pos,\r\n                n = pos,\r\n                \"s\" === input.substr(pos, 1).toLowerCase() ? (e = input.substr(pos, 1),\r\n                pos++) : (e = null,\r\n                0 === reportFailures && matchFailed('\"s\"')),\r\n                null !== e ? (/^['a'|'d']/i.test(input.charAt(pos)) ? (t = input.charAt(pos),\r\n                pos++) : (t = null,\r\n                0 === reportFailures && matchFailed(\"['a'|'d']i\")),\r\n                null !== (t = null !== t ? t : \"\") ? e = [e, t] : (e = null,\r\n                pos = n)) : (e = null,\r\n                pos = n),\r\n                null !== e && (e = {\r\n                    sort: {\r\n                        order: e[1].toLowerCase() || \"a\"\r\n                    }\r\n                }),\r\n                null === e && (pos = i),\r\n                e\r\n            }\r\n            function parse_floorMod() {\r\n                var e, t;\r\n                return t = pos,\r\n                \"flr\" === input.substr(pos, 3) ? (e = \"flr\",\r\n                pos += 3) : (e = null,\r\n                0 === reportFailures && matchFailed('\"flr\"')),\r\n                null !== e && (e = {\r\n                    round: {\r\n                        type: \"floor\"\r\n                    }\r\n                }),\r\n                null === e && (pos = t),\r\n                e\r\n            }\r\n            function parse_multipleMod() {\r\n                var e, t, i, n;\r\n                return i = pos,\r\n                n = pos,\r\n                \"x\" === input.substr(pos, 1).toLowerCase() ? (e = input.substr(pos, 1),\r\n                pos++) : (e = null,\r\n                0 === reportFailures && matchFailed('\"x\"')),\r\n                null !== e && null !== (t = parse_integer()) ? e = [e, t] : (e = null,\r\n                pos = n),\r\n                null !== e && (e = {\r\n                    multiple: {\r\n                        times: e[1]\r\n                    }\r\n                }),\r\n                null === e && (pos = i),\r\n                e\r\n            }\r\n            function parse_successMod() {\r\n                var e, t, i, n, o, r, a, s, l;\r\n                return n = pos,\r\n                o = pos,\r\n                null !== (e = parse_comparisonPoint()) ? (r = pos,\r\n                \"f\" === input.substr(pos, 1).toLowerCase() ? (t = input.substr(pos, 1),\r\n                pos++) : (t = null,\r\n                0 === reportFailures && matchFailed('\"f\"')),\r\n                null !== t && null !== (i = parse_comparisonPoint()) ? t = [t, i] : (t = null,\r\n                pos = r),\r\n                null !== (t = null !== t ? t : \"\") ? e = [e, t] : (e = null,\r\n                pos = o)) : (e = null,\r\n                pos = o),\r\n                null !== e && (a = e[0],\r\n                s = e[1],\r\n                l = {\r\n                    success: a\r\n                },\r\n                \"\" !== s && (l.failure = s[1]),\r\n                e = l),\r\n                null === e && (pos = n),\r\n                e\r\n            }\r\n            function parse_matchMod() {\r\n                var e, t, i, n, o, r, a, s;\r\n                return n = pos,\r\n                o = pos,\r\n                109 === input.charCodeAt(pos) ? (e = \"m\",\r\n                pos++) : (e = null,\r\n                0 === reportFailures && matchFailed('\"m\"')),\r\n                null !== e && null !== (t = parse_matchThreshold()) && null !== (i = null !== (i = parse_comparisonPoint()) ? i : \"\") ? e = [e, t, i] : (e = null,\r\n                pos = o),\r\n                null !== e && (r = e[1],\r\n                a = e[2],\r\n                (s = {\r\n                    match: \"\" !== a ? a : {}\r\n                }).match.threshold = r,\r\n                e = s),\r\n                null === e && (pos = n),\r\n                e\r\n            }\r\n            function parse_matchTotalMod() {\r\n                var e, t, i, n, o, r, a, s;\r\n                return n = pos,\r\n                o = pos,\r\n                \"mt\" === input.substr(pos, 2) ? (e = \"mt\",\r\n                pos += 2) : (e = null,\r\n                0 === reportFailures && matchFailed('\"mt\"')),\r\n                null !== e && null !== (t = parse_matchThreshold()) && null !== (i = null !== (i = parse_comparisonPoint()) ? i : \"\") ? e = [e, t, i] : (e = null,\r\n                pos = o),\r\n                null !== e && (r = e[1],\r\n                a = e[2],\r\n                (s = {\r\n                    match: \"\" !== a ? a : {}\r\n                }).match.threshold = r,\r\n                s.match.total = !0,\r\n                e = s),\r\n                null === e && (pos = n),\r\n                e\r\n            }\r\n            function parse_matchThreshold() {\r\n                var e, t, i, n;\r\n                for (i = pos,\r\n                e = [],\r\n                /^[0-9]/.test(input.charAt(pos)) ? (t = input.charAt(pos),\r\n                pos++) : (t = null,\r\n                0 === reportFailures && matchFailed(\"[0-9]\")); null !== t; )\r\n                    e.push(t),\r\n                    /^[0-9]/.test(input.charAt(pos)) ? (t = input.charAt(pos),\r\n                    pos++) : (t = null,\r\n                    0 === reportFailures && matchFailed(\"[0-9]\"));\r\n                return null !== e && (e = (n = e) && n != [] && parseInt(n.join(\"\"), 10) > 2 ? parseInt(n.join(\"\"), 10) : 2),\r\n                null === e && (pos = i),\r\n                e\r\n            }\r\n            function parse_comparisonPoint() {\r\n                var e, t, i, n, o;\r\n                return i = pos,\r\n                n = pos,\r\n                null !== (e = null !== (e = parse_comparison()) ? e : \"\") && null !== (t = parse_integer()) ? e = [e, t] : (e = null,\r\n                pos = n),\r\n                null !== e && (e = {\r\n                    comp: (\"\" == (o = e[0]) ? \"=\" : o) + \"=\",\r\n                    point: e[1]\r\n                }),\r\n                null === e && (pos = i),\r\n                e\r\n            }\r\n            function parse_comparison() {\r\n                var e;\r\n                return /^[>|<|=]/.test(input.charAt(pos)) ? (e = input.charAt(pos),\r\n                pos++) : (e = null,\r\n                0 === reportFailures && matchFailed(\"[>|<|=]\")),\r\n                e\r\n            }\r\n            function parse_mathExpression() {\r\n                var e, t, i, n, o, r, a, s, l;\r\n                return s = pos,\r\n                l = pos,\r\n                null !== (e = parse__()) && null !== (t = parse_mathExpressionPrimary()) && null !== (i = parse__()) && null !== (n = parse_operator()) && null !== (o = parse__()) && null !== (r = parse_mathExpression()) && null !== (a = parse__()) ? e = [e, t, i, n, o, r, a] : (e = null,\r\n                pos = l),\r\n                null !== e && (e = e[1] + e[3] + e[5]),\r\n                null === e && (pos = s),\r\n                null === e && (s = pos,\r\n                l = pos,\r\n                null !== (e = parse__()) && null !== (t = parse_mathExpressionPrimary()) && null !== (i = parse__()) ? e = [e, t, i] : (e = null,\r\n                pos = l),\r\n                null !== e && (e = e[1]),\r\n                null === e && (pos = s)),\r\n                e\r\n            }\r\n            function parse_mathExpressionPrimary() {\r\n                var e, t, i, n, o, r, a;\r\n                return r = pos,\r\n                a = pos,\r\n                null !== (e = parse__()) && null !== (t = parse_number()) && null !== (i = parse__()) ? e = [e, t, i] : (e = null,\r\n                pos = a),\r\n                null !== e && (e = e[1]),\r\n                null === e && (pos = r),\r\n                null === e && (r = pos,\r\n                a = pos,\r\n                40 === input.charCodeAt(pos) ? (e = \"(\",\r\n                pos++) : (e = null,\r\n                0 === reportFailures && matchFailed('\"(\"')),\r\n                null !== e && null !== (t = parse__()) && null !== (i = parse_mathExpression()) && null !== (n = parse__()) ? (41 === input.charCodeAt(pos) ? (o = \")\",\r\n                pos++) : (o = null,\r\n                0 === reportFailures && matchFailed('\")\"')),\r\n                null !== o ? e = [e, t, i, n, o] : (e = null,\r\n                pos = a)) : (e = null,\r\n                pos = a),\r\n                null !== e && (e = \"(\" + e[2] + \")\"),\r\n                null === e && (pos = r)),\r\n                e\r\n            }\r\n            function parse_inlineLabelWithSpace() {\r\n                var e, t, i, n, o;\r\n                return n = pos,\r\n                o = pos,\r\n                null !== (e = parse__()) && null !== (t = parse_inlineLabel()) && null !== (i = parse__()) ? e = [e, t, i] : (e = null,\r\n                pos = o),\r\n                null !== e && (e = e[1]),\r\n                null === e && (pos = n),\r\n                e\r\n            }\r\n            function parse_inlineLabel() {\r\n                var e, t, i, n, o;\r\n                if (n = pos,\r\n                o = pos,\r\n                91 === input.charCodeAt(pos) ? (e = \"[\",\r\n                pos++) : (e = null,\r\n                0 === reportFailures && matchFailed('\"[\"')),\r\n                null !== e) {\r\n                    for (t = [],\r\n                    /^[^\\]]/.test(input.charAt(pos)) ? (i = input.charAt(pos),\r\n                    pos++) : (i = null,\r\n                    0 === reportFailures && matchFailed(\"[^\\\\]]\")); null !== i; )\r\n                        t.push(i),\r\n                        /^[^\\]]/.test(input.charAt(pos)) ? (i = input.charAt(pos),\r\n                        pos++) : (i = null,\r\n                        0 === reportFailures && matchFailed(\"[^\\\\]]\"));\r\n                    null !== t ? (93 === input.charCodeAt(pos) ? (i = \"]\",\r\n                    pos++) : (i = null,\r\n                    0 === reportFailures && matchFailed('\"]\"')),\r\n                    null !== i ? e = [e, t, i] : (e = null,\r\n                    pos = o)) : (e = null,\r\n                    pos = o)\r\n                } else\r\n                    e = null,\r\n                    pos = o;\r\n                return null !== e && (e = new Label(e[1].join(\"\"))),\r\n                null === e && (pos = n),\r\n                e\r\n            }\r\n            function parse_operator() {\r\n                var e;\r\n                return /^[+|\\-|*|\\/|%]/.test(input.charAt(pos)) ? (e = input.charAt(pos),\r\n                pos++) : (e = null,\r\n                0 === reportFailures && matchFailed(\"[+|\\\\-|*|\\\\/|%]\")),\r\n                e\r\n            }\r\n            function parse_number() {\r\n                var e;\r\n                return null === (e = parse_exponent()) && null === (e = parse_float()) && (e = parse_signedInteger()),\r\n                e\r\n            }\r\n            function parse_integer() {\r\n                var e, t, i;\r\n                if (i = pos,\r\n                /^[0-9]/.test(input.charAt(pos)) ? (t = input.charAt(pos),\r\n                pos++) : (t = null,\r\n                0 === reportFailures && matchFailed(\"[0-9]\")),\r\n                null !== t)\r\n                    for (e = []; null !== t; )\r\n                        e.push(t),\r\n                        /^[0-9]/.test(input.charAt(pos)) ? (t = input.charAt(pos),\r\n                        pos++) : (t = null,\r\n                        0 === reportFailures && matchFailed(\"[0-9]\"));\r\n                else\r\n                    e = null;\r\n                return null !== e && (e = parseInt(e.join(\"\"), 10)),\r\n                null === e && (pos = i),\r\n                e\r\n            }\r\n            function parse_signedInteger() {\r\n                var e, t, i, n, o, r;\r\n                return i = pos,\r\n                n = pos,\r\n                /^[+|\\-]/.test(input.charAt(pos)) ? (e = input.charAt(pos),\r\n                pos++) : (e = null,\r\n                0 === reportFailures && matchFailed(\"[+|\\\\-]\")),\r\n                null !== (e = null !== e ? e : \"\") && null !== (t = parse_integer()) ? e = [e, t] : (e = null,\r\n                pos = n),\r\n                null !== e && (o = e[0],\r\n                r = e[1],\r\n                e = \"-\" == o ? -1 * r : r),\r\n                null === e && (pos = i),\r\n                e\r\n            }\r\n            function parse_float() {\r\n                var e, t, i, n, o, r, a, s;\r\n                if (o = pos,\r\n                r = pos,\r\n                null !== (e = null !== (e = parse_signedInteger()) ? e : \"\"))\r\n                    if (46 === input.charCodeAt(pos) ? (t = \".\",\r\n                    pos++) : (t = null,\r\n                    0 === reportFailures && matchFailed('\".\"')),\r\n                    null !== t) {\r\n                        if (/^[0-9]/.test(input.charAt(pos)) ? (n = input.charAt(pos),\r\n                        pos++) : (n = null,\r\n                        0 === reportFailures && matchFailed(\"[0-9]\")),\r\n                        null !== n)\r\n                            for (i = []; null !== n; )\r\n                                i.push(n),\r\n                                /^[0-9]/.test(input.charAt(pos)) ? (n = input.charAt(pos),\r\n                                pos++) : (n = null,\r\n                                0 === reportFailures && matchFailed(\"[0-9]\"));\r\n                        else\r\n                            i = null;\r\n                        null !== i ? e = [e, t, i] : (e = null,\r\n                        pos = r)\r\n                    } else\r\n                        e = null,\r\n                        pos = r;\r\n                else\r\n                    e = null,\r\n                    pos = r;\r\n                return null !== e && (a = e[0],\r\n                s = e[2],\r\n                e = 0 === a && 1 / a < 0 ? -1 * parseFloat(a + \".\" + s.join(\"\")) : parseFloat(a + \".\" + s.join(\"\"))),\r\n                null === e && (pos = o),\r\n                e\r\n            }\r\n            function parse_exponent() {\r\n                var e, t, i, n, o, r, a, s, l, c;\r\n                return r = pos,\r\n                a = pos,\r\n                null !== (e = null !== (e = parse_signedInteger()) ? e : \"\") ? (46 === input.charCodeAt(pos) ? (t = \".\",\r\n                pos++) : (t = null,\r\n                0 === reportFailures && matchFailed('\".\"')),\r\n                null !== t && null !== (i = parse_integer()) ? (101 === input.charCodeAt(pos) ? (n = \"e\",\r\n                pos++) : (n = null,\r\n                0 === reportFailures && matchFailed('\"e\"')),\r\n                null !== n && null !== (o = parse_signedInteger()) ? e = [e, t, i, n, o] : (e = null,\r\n                pos = a)) : (e = null,\r\n                pos = a)) : (e = null,\r\n                pos = a),\r\n                null !== e && (s = e[0],\r\n                l = e[2],\r\n                c = e[4],\r\n                e = parseFloat(s + \".\" + l + \"e\" + c)),\r\n                null === e && (pos = r),\r\n                null === e && (r = pos,\r\n                a = pos,\r\n                null !== (e = parse_signedInteger()) ? (101 === input.charCodeAt(pos) ? (t = \"e\",\r\n                pos++) : (t = null,\r\n                0 === reportFailures && matchFailed('\"e\"')),\r\n                null !== t && null !== (i = parse_signedInteger()) ? e = [e, t, i] : (e = null,\r\n                pos = a)) : (e = null,\r\n                pos = a),\r\n                null !== e && (e = function(e, t, i) {\r\n                    return parseFloat(t + \"e\" + i)\r\n                }(0, e[0], e[2])),\r\n                null === e && (pos = r)),\r\n                e\r\n            }\r\n            function parse__() {\r\n                var e, t, i;\r\n                for (i = pos,\r\n                e = [],\r\n                /^[ |\\t]/.test(input.charAt(pos)) ? (t = input.charAt(pos),\r\n                pos++) : (t = null,\r\n                0 === reportFailures && matchFailed(\"[ |\\\\t]\")); null !== t; )\r\n                    e.push(t),\r\n                    /^[ |\\t]/.test(input.charAt(pos)) ? (t = input.charAt(pos),\r\n                    pos++) : (t = null,\r\n                    0 === reportFailures && matchFailed(\"[ |\\\\t]\"));\r\n                return null !== e && (e = e.join(\"\")),\r\n                null === e && (pos = i),\r\n                e\r\n            }\r\n            function parse___() {\r\n                var e, t, i;\r\n                if (i = pos,\r\n                /^[ |\\t]/.test(input.charAt(pos)) ? (t = input.charAt(pos),\r\n                pos++) : (t = null,\r\n                0 === reportFailures && matchFailed(\"[ |\\\\t]\")),\r\n                null !== t)\r\n                    for (e = []; null !== t; )\r\n                        e.push(t),\r\n                        /^[ |\\t]/.test(input.charAt(pos)) ? (t = input.charAt(pos),\r\n                        pos++) : (t = null,\r\n                        0 === reportFailures && matchFailed(\"[ |\\\\t]\"));\r\n                else\r\n                    e = null;\r\n                return null !== e && (e = e.join(\"\")),\r\n                null === e && (pos = i),\r\n                e\r\n            }\r\n            function cleanupExpected(e) {\r\n                e.sort();\r\n                for (var t = null, i = [], n = 0; n < e.length; n++)\r\n                    e[n] !== t && (i.push(e[n]),\r\n                    t = e[n]);\r\n                return i\r\n            }\r\n            function computeErrorPosition() {\r\n                for (var e = 1, t = 1, i = !1, n = 0; n < Math.max(pos, rightmostFailuresPos); n++) {\r\n                    var o = input.charAt(n);\r\n                    \"\\n\" === o ? (i || e++,\r\n                    t = 1,\r\n                    i = !1) : \"\\r\" === o || \"\\u2028\" === o || \"\\u2029\" === o ? (e++,\r\n                    t = 1,\r\n                    i = !0) : (t++,\r\n                    i = !1)\r\n                }\r\n                return {\r\n                    line: e,\r\n                    column: t\r\n                }\r\n            }\r\n            function log(e) {\r\n                console.log(e)\r\n            }\r\n            function MathExpression(e) {\r\n                this.type = d20.dice.TYPE_MATH_EXPR,\r\n                this.expr = e != undefined ? e : \"\"\r\n            }\r\n            function RollExpression(e, t) {\r\n                this.type = d20.dice.TYPE_ROLL_EXPR,\r\n                this.dice = e,\r\n                this.sides = t,\r\n                this.mods = {}\r\n            }\r\n            function FateRollExpression(e) {\r\n                this.type = d20.dice.TYPE_ROLL_EXPR,\r\n                this.dice = e,\r\n                this.fate = !0,\r\n                this.mods = {}\r\n            }\r\n            function TableRollExpression(e, t) {\r\n                this.type = d20.dice.TYPE_ROLL_EXPR,\r\n                this.dice = e,\r\n                this.table = t,\r\n                this.mods = {}\r\n            }\r\n            function GroupExpression(e, t) {\r\n                this.type = d20.dice.TYPE_GROUP_EXPR,\r\n                this.rolls = e,\r\n                this.mods = t || {}\r\n            }\r\n            function Label(e) {\r\n                this.type = d20.dice.TYPE_LABEL,\r\n                this.text = e\r\n            }\r\n            function Comment(e) {\r\n                this.type = d20.dice.TYPE_COMMENT,\r\n                this.text = e\r\n            }\r\n            function mergeExpressions(e, t) {\r\n                if (\"string\" == typeof e) {\r\n                    if (0 == e.length)\r\n                        return t;\r\n                    e = new MathExpression(e)\r\n                }\r\n                if (\"string\" == typeof t) {\r\n                    if (0 == t.length)\r\n                        return e;\r\n                    t = new MathExpression(t)\r\n                }\r\n                if (Array.isArray(e) && Array.isArray(t)) {\r\n                    if (e[e.length - 1].type == d20.dice.TYPE_MATH_EXPR && t[0].type == d20.dice.TYPE_MATH_EXPR) {\r\n                        var i = e.pop();\r\n                        t[0].expr = i.expr + t[0].expr\r\n                    }\r\n                    return e.concat(t)\r\n                }\r\n                return Array.isArray(e) ? (e[e.length - 1].type == d20.dice.TYPE_MATH_EXPR && t.type == d20.dice.TYPE_MATH_EXPR ? e[e.length - 1].expr += t.expr : e.push(t),\r\n                e) : Array.isArray(t) ? (t[0].type == d20.dice.TYPE_MATH_EXPR && e.type == d20.dice.TYPE_MATH_EXPR ? t[0].expr = e.expr + t[0].expr : t.unshift(e),\r\n                t) : e.type == d20.dice.TYPE_MATH_EXPR && t.type == d20.dice.TYPE_MATH_EXPR ? (e.expr += t.expr,\r\n                e) : [e, t]\r\n            }\r\n            function processMods(e, t) {\r\n                var i = e;\r\n                if (t.length > 0)\r\n                    for (var n in t[0]) {\r\n                        if (i[n] != undefined)\r\n                            throw {\r\n                                message: \"'\" + n + \"' roll modifier can only be specified once\"\r\n                            };\r\n                        i[n] = t[0][n]\r\n                    }\r\n                return i\r\n            }\r\n            var parseFunctions = {\r\n                start: parse_start,\r\n                rollExpression: parse_rollExpression,\r\n                rollExpressionPrimary: parse_rollExpressionPrimary,\r\n                validRollSuffix: parse_validRollSuffix,\r\n                rollGroup: parse_rollGroup,\r\n                rollGroupExpression: parse_rollGroupExpression,\r\n                labelAwareRollOperator: parse_labelAwareRollOperator,\r\n                rollOperator: parse_rollOperator,\r\n                fullRoll: parse_fullRoll,\r\n                coreRoll: parse_coreRoll,\r\n                numberOfDice: parse_numberOfDice,\r\n                numberOfSides: parse_numberOfSides,\r\n                groupMods: parse_groupMods,\r\n                rollMods: parse_rollMods,\r\n                explodingMod: parse_explodingMod,\r\n                compoundingMod: parse_compoundingMod,\r\n                penetratingMod: parse_penetratingMod,\r\n                keepMod: parse_keepMod,\r\n                dropMod: parse_dropMod,\r\n                customCritMod: parse_customCritMod,\r\n                customFumbleMod: parse_customFumbleMod,\r\n                rerollMod: parse_rerollMod,\r\n                rerollOnceMod: parse_rerollOnceMod,\r\n                sortMod: parse_sortMod,\r\n                floorMod: parse_floorMod,\r\n                multipleMod: parse_multipleMod,\r\n                successMod: parse_successMod,\r\n                matchMod: parse_matchMod,\r\n                matchTotalMod: parse_matchTotalMod,\r\n                matchThreshold: parse_matchThreshold,\r\n                comparisonPoint: parse_comparisonPoint,\r\n                comparison: parse_comparison,\r\n                mathExpression: parse_mathExpression,\r\n                mathExpressionPrimary: parse_mathExpressionPrimary,\r\n                inlineLabelWithSpace: parse_inlineLabelWithSpace,\r\n                inlineLabel: parse_inlineLabel,\r\n                operator: parse_operator,\r\n                number: parse_number,\r\n                integer: parse_integer,\r\n                signedInteger: parse_signedInteger,\r\n                float: parse_float,\r\n                exponent: parse_exponent,\r\n                _: parse__,\r\n                __: parse___\r\n            };\r\n            if (startRule !== undefined) {\r\n                if (parseFunctions[startRule] === undefined)\r\n                    throw new Error(\"Invalid rule name: \" + quote(startRule) + \".\")\r\n            } else\r\n                startRule = \"start\";\r\n            var pos = 0\r\n              , reportFailures = 0\r\n              , rightmostFailuresPos = 0\r\n              , rightmostFailuresExpected = []\r\n              , d20 = \"undefined\" != typeof window && window.d20 !== undefined ? window.d20 : {};\r\n            d20.dice == undefined && (d20.dice = d20.dice || {},\r\n            d20.dice.TYPE_MATH_EXPR = \"M\",\r\n            d20.dice.TYPE_ROLL_EXPR = \"R\",\r\n            d20.dice.TYPE_GROUP_EXPR = \"G\",\r\n            d20.dice.TYPE_LABEL = \"L\",\r\n            d20.dice.TYPE_COMMENT = \"C\",\r\n            d20.dice.TYPE_VALIDATED_ROLLS = \"V\");\r\n            var result = parseFunctions[startRule]();\r\n            if (null === result || pos !== input.length) {\r\n                var offset = Math.max(pos, rightmostFailuresPos)\r\n                  , found = offset < input.length ? input.charAt(offset) : null\r\n                  , errorPosition = computeErrorPosition();\r\n                throw new this.SyntaxError(cleanupExpected(rightmostFailuresExpected),found,offset,errorPosition.line,errorPosition.column)\r\n            }\r\n            return result\r\n        },\r\n        toSource: function() {\r\n            return this._source\r\n        },\r\n        SyntaxError: function(e, t, i, n, o) {\r\n            function r(e, t) {\r\n                var i;\r\n                switch (e.length) {\r\n                case 0:\r\n                    i = \"end of input\";\r\n                    break;\r\n                case 1:\r\n                    i = e[0];\r\n                    break;\r\n                default:\r\n                    i = e.slice(0, e.length - 1).join(\", \") + \" or \" + e[e.length - 1]\r\n                }\r\n                return \"Expected \" + i + \" but \" + (t ? quote(t) : \"end of input\") + \" found.\"\r\n            }\r\n            this.name = \"SyntaxError\",\r\n            this.expected = e,\r\n            this.found = t,\r\n            this.message = r(e, t),\r\n            this.offset = i,\r\n            this.line = n,\r\n            this.column = o\r\n        }\r\n    };\r\n    return result.SyntaxError.prototype = Error.prototype,\r\n    result\r\n}();\r\n\r\n\r\nd20.getRollResults = async (rollInput) => {\r\n    let rollId = generateUUID();\r\n    let roll = [{\r\n        rollid: rollId,\r\n        rolltype: \"rollresult\",\r\n        vre: {\r\n            resultType: \"sum\",\r\n            rolls: d20.DicePEG.parse(rollInput, 'start'),\r\n            type: 'V'\r\n        }\r\n    }];\r\n    var t = {\r\n        cid: window.campaign_storage_path,\r\n        fbnum: window.FIREBASE_ROOT,\r\n        authkey: window.GNTKN,\r\n        pid: window.currentPlayer.id,\r\n        rolls: roll,\r\n        use3d: window.is_playerapp ? window.currentPlayer.get(\"apptddiceenabled\") : window.currentPlayer.get(\"tddiceenabled\")\r\n    };\r\n\r\n    let results = await $.ajax({\r\n        url: \"https://app.roll20.net/doroll\",\r\n        type: \"POST\",\r\n        data: JSON.stringify(t),\r\n        contentType: \"application/json; charset=utf-8\",\r\n        dataType: \"json\",\r\n    });\r\n    let rollsResult = [];\r\n    for (var key in results){\r\n        let result = results[key];\r\n        if (result.error == undefined) {\r\n            result.key = key;\r\n            rollsResult.push(result);\r\n        } else\r\n            console.error(result);\r\n    }\r\n    return rollsResult;\r\n}\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (d20);\n\n//# sourceURL=webpack:///./src/d20/d20.js?");

/***/ }),

/***/ "./src/on/dispatchOnEvent.js":
/*!***********************************!*\
  !*** ./src/on/dispatchOnEvent.js ***!
  \***********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\nlet events = {};\r\nfunction dispatchOnEvent(eventName, ...args){\r\n    if(Array.isArray(events[eventName])){\r\n        for(let callback of events[eventName]){\r\n            if(typeof callback === 'function'){\r\n                callback(...args);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nfunction on(eventName, callback){\r\n    if(!Array.isArray(events[eventName]))\r\n        events[eventName] = [];\r\n    events[eventName].push(callback);\r\n}\r\n\r\nwindow.on = on;\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (dispatchOnEvent);\n\n//# sourceURL=webpack:///./src/on/dispatchOnEvent.js?");

/***/ })

/******/ });